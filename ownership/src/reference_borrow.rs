pub fn reference_borrow() {
    /*
     러스트에는 소유권의 개념이 있기 때문에 String을 호출하는 함수쪽으로 보내면
     원래 있던 함수 내부에서는 이 String을 사용할 수 없다.
     이를 해결하기 위해 러스트는 참조자를 사용한다.
     소유권을 넘기는 대신 개체에 대한 참조자를 넘긴다.

     이 참조자는 소유권을 가지고 있지 않아서 스코프를 벗어나도 메모리를 반환하지 않는다.
     함수의 파라미터로 참조자를 만드는 것을 빌림 이라고 부른다. -> Read만 된다.
    */
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("The length of '{}' is {}.", s1, len);

    /*
      가변 참조자도 있다. -> Read & Write
      &대신 &mut을 붙이면 된다.
      대신 가변 참조자는 하나만 존재할 수 있다. -> 데이터 레이스 방지 (두개의 포인터가 같은 데이터를 가리키고 있을때)
      공식문서에서는 컴파일에러가 발생한다고 되어있는데, 러스트 버전이 높아서그런지 발생하지 않는다.
      불변참조자를 가지고 있을때는 가변참조자를 만들 수 없다고 한다.
    */
    let mut s = String::from("hello");
    let _r1 = &s;
    let _r2 = &s;
    let _r3 = &mut s;

    /*
     러스트는 댕글링 포인터를 허용하지 않는다.
     댕글링 포인터란, 메모리를 반환했는데도 포인터가 여전히 그 메모리를 가리키고 있는 경우를 말한다.
     러스트는 컴파일 타임에 댕글링 포인터를 찾아낸다.
     러스트는 댕글링 포인터를 허용하지 않는 대신, 참조자를 사용할 때는 항상 유효한 값을 가리키고 있다는 것을 보장한다.
    */
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

/*
  dangle() 함수 내부에서 s의 참조자를 반환하는데, s는 함수가 끝나면서 메모리를 반환하기 때문에 댕글링 포인터가 된다.
  따라서 컴파일 시점에 에러가 발생한다.
  이것을 방지하기 위해 String을 직접 반환한다.
*/
// fn dangle() -> &String {
//     let s = String::from("hello");

//     &s
// }
