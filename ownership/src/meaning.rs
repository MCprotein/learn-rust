pub fn meaning() {
    /*
       s는 스트링 리터럴이다.
       변수는 선언된 시점부터 현재 스코프가 끝날때까지 유효하다.
       모든 데이터 타입은 스택에 저장되었다가 스코프를 벗어날때 POP 된다.
       스트링 리터럴, 정수형과 같이 크기가 컴파일 타임에 결정되는 데이터 타입은 스택에 저장되기때문에,
       실제 값의 복사본이 빠르게 만들어질 수 있다. 따라서 y가 생성된 후에 x가 유효하지 않도록 해야될 이유가 없다.
       이렇게 스택에 저장되는 데이터 타입에는 Copy 트레잇이라고 불리는 annotation이 구현되어 있다.
       Copy 트레잇이 있으면 대입 과정 후에도 이전 변수를 계속 사용할 수 있다.
       Drop 트레잇이 있으면 Copy 트레잇을 어노테이션할 수 없게 한다.

       Copy가능 타입
       - 정수형 타입들
       - bool
       - 부동 소수점 타입들
       - Copy가 가능한 타입으로만 구성된 튜플들 ex) (i32, i32)
    */
    let x = "copycopy 열매가 두배";
    let y = x;
    println!("{}, {}", x, y);

    /*
       String은 mutable이지만, 스트링 리터럴은 immutable이다.
       메모리를 쓰는 방식이 다르기 때문.
    */
    let mut s = String::from("hello");
    s.push_str(", world!");
    println!("{}", s);

    /*
       아래는 x의 복사값이 y에 저장된다.
    */
    let x = 5;
    let _y = x;

    /*
        아래는 위와 다른 방식이다.
        s2에 복사되는 데이터는 스택에 있는 포인터, 길이값, 용량값이 복사된다.
        포인터가 가리키고 있는 힙 메모리 상의 데이터는 복사되지 않는다.
        s1는 무효화되어 더이상 사용할 수 없다.
    */
    let s1 = String::from("hello");
    let s2 = s1;
    /*
       clone(): 힙 데이터 깊은복사
    */
    let s3 = s2.clone();
    println!("{}, {}", s2, s3);
    /*
       스트링 리터럴은 컴파일 타임에 크기가 정해져 있기 때문에
       스택에 저장된다.
       String은 컴파일 타임에 크기를 알 수 없기 때문에
       힙에 저장된다. (런타임에 운영체제로부터 메모리를 할당받는다.)
       힙에 저장된 데이터는 스코프를 벗어나도 POP 되지 않는다.
       스코프를 벗어나도 POP 되지 않는 데이터는 메모리 누수를 발생시킨다.
       이를 방지하기 위해 Rust는 메모리를 자동으로 반환하는 메커니즘을 가지고 있다.
       C++에서는 RAII(Resource Acquisition Is Initialization)라고 한다.
       Rust는 변수가 스코프를 벗어나면 자동으로 drop 함수를 호출한다.
       drop 함수는 힙에 할당된 메모리를 반환한다.
       이러한 방식을 move라고 한다.
    */

    /*
       String은 문자열의 내용물을 담고있는 메모리의 포인터, 길이, 용량으로 구성된 정보가 스택에 저장된다.
       내용물 데이터는 힙에 저장된다.
       길이: 내용물이 얼마나 많은 메모리를 사용하고 있는지 표기 (bytes)
       용량: String이 운영체제로부터 할당받은 메모리의 크기 (bytes)
    */
}
